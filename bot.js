import TelegramBot from 'node-telegram-bot-api';
import Imap from 'imap';
import { simpleParser } from 'mailparser';

// –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ—á—Ç–æ–≤—ã—Ö —è—â–∏–∫–æ–≤
const mailboxes = {
    mailbox1: {
        name: "aristosand@mail.ru",
        email: process.env.MAIL_RU_EMAIL_1,
        password: process.env.MAIL_RU_PASSWORD_1,
        emoji: 'üîµ'  // –°–∏–Ω–∏–π –∫—Ä—É–≥
    },
    mailbox2: {
        name: "aristoss@inbox.ru",
        email: process.env.MAIL_RU_EMAIL_2,
        password: process.env.MAIL_RU_PASSWORD_2,
        emoji: 'üü¢'  // –ó–µ–ª–µ–Ω—ã–π –∫—Ä—É–≥
    }
};

// –ü–æ–ª—É—á–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–∑ –æ–∫—Ä—É–∂–µ–Ω–∏—è Railway
const botToken = process.env.TELEGRAM_BOT_TOKEN;

// –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –æ—à–∏–±–æ–∫
if (!botToken) {
    console.error('–û—à–∏–±–∫–∞: –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –æ–∫—Ä—É–∂–µ–Ω–∏—è TELEGRAM_BOT_TOKEN. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –≤ Railway.');
    process.exit(1); // –ó–∞–≤–µ—Ä—à–∞–µ–º –ø—Ä–æ–≥—Ä–∞–º–º—É —Å –æ—à–∏–±–∫–æ–π
}
for (const key in mailboxes){
    const mailbox = mailboxes[key]
    if (!mailbox.email || !mailbox.password){
    console.error(`–û—à–∏–±–∫–∞: –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –¥–ª—è –ø–æ—á—Ç–æ–≤–æ–≥–æ —è—â–∏–∫–∞ ${mailbox.name}. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –≤ Railway.`);
        process.exit(1) // –ó–∞–≤–µ—Ä—à–∞–µ–º –ø—Ä–æ–≥—Ä–∞–º–º—É —Å –æ—à–∏–±–∫–æ–π
    }
}


const bot = new TelegramBot(botToken, { polling: true });


async function checkUnreadEmailsMailRu(chatId, email, password, mailboxName) {
    const imap = new Imap({
        user: email,
        password: password,
        host: 'imap.mail.ru',
        port: 993,
        tls: true,
    });

    imap.once('ready', () => {
        imap.openBox('INBOX', true, (err, box) => {
            if (err) {
                console.error('Error opening mailbox:', err);
                bot.sendMessage(chatId, `–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ –ø–æ—á—Ç–æ–≤–æ–≥–æ —è—â–∏–∫–∞ ${mailboxName}.`);
                imap.end();
                return;
            }
            imap.search(['UNSEEN'], (err, results) => {
                if (err) {
                    console.error('Error searching for unread messages:', err);
                    bot.sendMessage(chatId, `–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ –Ω–µ–ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –≤ ${mailboxName}.`);
                    imap.end();
                    return;
                }

                if (results.length === 0) {
                    bot.sendMessage(chatId, `–£ –≤–∞—Å –Ω–µ—Ç –Ω–µ–ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã—Ö –ø–∏—Å–µ–º –≤ ${mailboxName}.`);
                    imap.end();
                    return;
                }
                bot.sendMessage(chatId, `–£ –≤–∞—Å ${results.length} –Ω–µ–ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã—Ö –ø–∏—Å–µ–º –≤ ${mailboxName}.`);

                const f = imap.fetch(results, { bodies: '', struct: true });

                f.on('message', (msg, seqno) => {
                    msg.on('body', (stream, info) => {
                        simpleParser(stream, {}, (err, mail) => {
                            if (err) {
                                console.error('Error parsing email:', err);
                                return;
                            }
                            bot.sendMessage(
                                chatId,
                                `**–û—Ç:** ${mail.from.text}\n**–¢–µ–º–∞:** ${mail.subject}\n**–î–∞—Ç–∞:** ${mail.date}`
                            );
                        });
                    });
                });

                f.once('error', (err) => {
                    console.error('Error fetching messages:', err);
                    bot.sendMessage(chatId, `–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø–∏—Å–µ–º –≤ ${mailboxName}.`);
                    imap.end();
                });

                f.once('end', () => {
                    imap.end();
                });
            });
        });
    });

    imap.once('error', (err) => {
        console.error('Connection error:', err);
        bot.sendMessage(chatId, `–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ø–æ—á—Ç–æ–≤–æ–º—É —Å–µ—Ä–≤–µ—Ä—É –¥–ª—è ${mailboxName}.`);
    });

    imap.connect();
}


// –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start
bot.onText(/\/start/, async (msg) => {
    const chatId = msg.chat.id;

    const mailboxKeyboard = {
        reply_markup: {
            inline_keyboard: Object.keys(mailboxes).map(key => [
                { text: `${mailboxes[key].emoji} ${mailboxes[key].name}`, callback_data: `check_${key}` }
            ])
        }
    };

    await bot.sendMessage(chatId, '–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ—á—Ç–æ–≤—ã–π —è—â–∏–∫ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏:', mailboxKeyboard);
});


// –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞–∂–∞—Ç–∏—è –Ω–∞ –∫–Ω–æ–ø–∫–∏
bot.on('callback_query', async (query) => {
    const chatId = query.message.chat.id;
    const data = query.data;

    if (data.startsWith('check_')) {
        const mailboxKey = data.split('_')[1];
        const selectedMailbox = mailboxes[mailboxKey];
        if (!selectedMailbox) {
              await bot.sendMessage(chatId, '–û—à–∏–±–∫–∞: –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ø–æ—á—Ç–æ–≤—ã–π —è—â–∏–∫.');
            return;
        }

       await checkUnreadEmailsMailRu(chatId, selectedMailbox.email, selectedMailbox.password, selectedMailbox.name);
       await bot.answerCallbackQuery(query.id);
    }
});

// Help command
bot.onText(/\/help/, async (msg) => {
    const chatId = msg.chat.id;
    await bot.sendMessage(chatId,
        '–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n' +
        '/start - –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –Ω–µ–ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã–µ –ø–∏—Å—å–º–∞'
    );
});

console.log('–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω...');
